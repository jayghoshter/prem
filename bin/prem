#!/usr/bin/env python3

from prem import PDF, CrossRef
from prem.utils import generic_open_linux, fetch_bibliography
import argparse
import re
from pyfzf.pyfzf import FzfPrompt
import plumbum
import click
from rich import print
from types import SimpleNamespace
import readline

def input_with_prefill(prompt, text):
    def hook():
        readline.insert_text(text)
        readline.redisplay()
    readline.set_pre_input_hook(hook)
    result = input(prompt)
    readline.set_pre_input_hook()
    return result

def check_doi_in_metadata(pdf, source):
    dois_in_mdata = pdf.find_in_metadata(PDF.doi_regex)

    if dois_in_mdata: 
        doi = dois_in_mdata[0]
        print(f"  > Found DOI: {doi} in file metadata")

        mdata = source.fetch_by_doi(doi)
        if not mdata:
            print(f"  > Error fetching metadata from {source.__class__.__name__}")
            return 
        print(f"  > Fetched metadata from {source.__class__.__name__} or local cache")

        mdata = source.extract(mdata)
        pdf.update_metadata(mdata)
        pdf.rename()

        return True
    return False

def check_doi_in_text(pdf, source, auto=False):
    text = pdf.pages_to_text(3)
    dois_in_text = PDF.doi_regex_compiled.findall(text)

    if dois_in_text:
        doi = dois_in_text[0]
        print(f"  > Found DOI: {doi} in pdf text")

        if not auto:
            doi = input_with_prefill("Correct DOI: ", doi)

        mdata = source.fetch_by_doi(doi)
        if not mdata: 
            print(f"  > Error fetching metadata from {source.__class__.__name__}")
            return False
        print(f"  > Fetched metadata from {source.__class__.__name__} or local cache")

        mdata = source.extract(mdata)
        pdf.update_metadata(mdata)
        pdf.rename()
        return True

    return False

def manual_query(pdf, source):
    fzf = FzfPrompt()
    FZF_FILE_OPTS =  '--cycle --bind="ctrl-x:execute@xdg-open {}@" --bind="ctrl-y:execute@echo {} | xclip -i -selection clipboard@"'

    header = """
# Manual query mode. 
# Please input the query text for crossref. It may be a partial title with or without author names.
# Only 120 characters from the first line are used in the query.
# The text extracted from the PDF follows for reference.

    """
    text = pdf.pages_to_text(3)
    pdf_process = generic_open_linux(pdf.filename)
    querystr = click.edit(header + text)
    if querystr: 
        querystr = querystr.split('\n')[0]
        querystr = querystr.encode('ascii', 'ignore')
        querystr = re.sub(r'[\-:\.\?,\s]+', '+', str(querystr))
        if len(querystr) > 120:
            querystr = querystr[:120]
        crossref_matches = source.query(querystr)
        crossref_matches_processed = list(map(source.extract, crossref_matches))
        crossref_identifiers = list(map(lambda x: f"{x['Year']} - {x['Author']} - {x['Title']}", crossref_matches_processed))
        selected = fzf.prompt(crossref_identifiers, FZF_FILE_OPTS)
        if selected:
            selected = selected[0]
            selected_index = crossref_identifiers.index(selected)
            pdf.update_metadata( crossref_matches_processed[selected_index] )
            pdf.rename()
    pdf_process.kill()

def driver(fname, **kwargs):
    print(f"Processing: {fname}")
    kwargs = SimpleNamespace(**kwargs)
    pdf = PDF(fname, name_template=kwargs.name_template)
    source = CrossRef

    print("  > Looking for DOI in file metadata.")
    if not check_doi_in_metadata(pdf, source):
        print("  > Couldn't find DOI in file metadata. Looking in text.")
        if not check_doi_in_text(pdf, source, kwargs.auto):
            if not kwargs.auto: 
                print(f"  > Couldn't find DOI in pdf text. Manual input required!")
                manual_query(pdf, source)

    if pdf.metadata.get('DOI'):
        if kwargs.bib:
            with open(kwargs.bib, 'a') as bibfile:
                bibfile.write(fetch_bibliography(pdf.metadata['DOI']))

def main():

    ap = argparse.ArgumentParser()

    ap.add_argument("files", nargs = '*', help="PDF files to operate on")
    ap.add_argument("-a", "--auto", action="store_true", help="auto mode, no manual inputs")
    ap.add_argument("-b", "--bib", nargs='?', const='ref.bib', help="Download bibtex citation info into [ref.bib or provided file]")
    ap.add_argument("-d", "--doi", help="Use provided DOI to fetch metadata and modify pdf")

    ap.add_argument("-nt", "--name-template", default="{year} - {author} - {title}.pdf", help="Name template for pdf filenames. Write metadata keys contained within {} for auto substitution.")

    args = ap.parse_args()

    if args.doi:
        assert len(args.files) == 1
        mdata = CrossRef.fetch_by_doi(args.doi)
        pdf = PDF(args.files[0], name_template=args.name_template)
        mdata = CrossRef.extract(mdata)
        pdf.metadata.update(mdata)
        pdf.rename()
    else: 
        for current_file in args.files: 
            driver(current_file, **vars(args))

if __name__ == "__main__": 
    main()
